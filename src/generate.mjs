import fs from 'fs';

const dir = './src/schemas/data';
const files = fs.readdirSync( dir );

for ( const file of files ) {
	const [ basename, ext ] = file.split( '.' );

	if ( ext !== 'json' ) {
		continue;
	}

	const path = `${dir}/${file}`;
	const schema = JSON.parse( fs.readFileSync( path, 'utf8' ) );
	const output = getOutput( schema );

	fs.writeFileSync( `./data/${basename}.php`, output );
}

/**
 * @param {object} schema
 * @returns {string}
 */
function getOutput( schema ) {
	let classComment = null;

	if ( schema.definitions ) {
		const headers = [];

		// iterate all definitions and add to headers
		for ( const key in schema.definitions ) {
			const definition = schema.definitions[key];

			headers.push( `@phpstan-type ${key} ${mapDefinition( definition, schema )}` );
		}

		classComment = `/**
${headers.map( ( line ) => ` * ${line}` ).join( '\n' )}
 */`;
	}

	let output = `<?php declare(strict_types = 1);
/**
 * This file is generated by the generate.mjs script.
 * Do not edit it manually.
 *
 * Source schema: ${schema.$id.replace( 'https://schemas.querymonitor.com/', '' )}
 */

/**
 * ${schema.description}
 *
 * @package query-monitor
 */
${classComment ? `\n${classComment}` : ''}
class QM_Data_${schema.title} extends QM_Data {`;

	for ( const key in schema.properties ) {
		const required = schema.required && schema.required.includes( key );
		const prop = resolveRef( schema.properties[key], schema );

		output += `
	/**`;

		if ( prop.description ) {
			output += `
	 * ${prop.description}
	 *`;
		}

		const type = mapType( prop, required, schema );

		if ( type.includes( 'array{' ) || prop.phpStanType ) {
			output += `
	 * @phpstan-var ${type}`;
		} else {
			output += `
	 * @var ${type}`;
		}

		output += `
	 */
	public $${key};
`;
	}

	output += `}
`;

	return output;
}

/**
 * @param {object} prop
 * @param {object} schema
 * @returns {string}
 */
function mapDefinition( prop, schema ) {
	return mapType( prop, true, schema, 0, '' );
}

/**
 * @param {object} prop
 * @param {boolean} required
 * @param {object} schema
 * @param {number} level
 * @param {string} prefix
 * @returns {string}
 */
function mapType( prop, required, schema, level = 0, prefix = '\t' ) {
	prop = resolveRef( prop, schema );

	const type = prop.enum || prop.type;
	const requiredMarker = required ? '' : '?';
	let returnType = type;

	if ( prop.phpStanType && prop.phpStanType !== 'object' ) {
		return `${requiredMarker}${prop.phpStanType}`;
	}

	if ( prop.phpType ) {
		return `${requiredMarker}${prop.phpType}`;
	}

	if ( prop.anyOf ) {
		return `${requiredMarker}${ prop.anyOf.map( ( one ) => mapType( one, true, schema, level, prefix ) ).join( '|' ) }`;
	}

	if ( prop.oneOf ) {
		return `${requiredMarker}${ prop.oneOf.map( ( one ) => mapType( one, true, schema, level, prefix ) ).join( '|' ) }`;
	}

	if ( typeof type === 'undefined' ) {
		return `${requiredMarker}mixed`;
	}

	if ( typeof type == 'object' ) {
		return `${requiredMarker}${ type.map( getPHPType ).join( '|' ) }`;
	}

	const indentation = '  '.repeat( level );
	let baseType = 'array';

	switch ( type ) {
		case 'array':
			if ( prop.items ) {
				returnType = `array<int, ${mapType( prop.items, true, schema, level, prefix )}>`;
			} else {
				returnType = 'array<int, mixed>';
			}
			break;
		case 'object':
			if ( prop.phpStanType && prop.phpStanType === 'object' ) {
				baseType = 'object';
			}
			if ( prop.properties ) {
				let type = `${baseType}{`;
				for ( const subKey in prop.properties ) {
					const subRequiredMarker = prop.required && prop.required.includes( subKey ) ? '' : '?';
					const sub = prop.properties[subKey];

					type += `
${prefix} *${indentation}   ${subKey}${subRequiredMarker}: ${mapType( sub, true, schema, level + 1, prefix )},`;
				}
				type += `
${prefix} *${indentation} }`;
				returnType = type;
			} else if ( prop.additionalProperties?.type ) {
				returnType = `${baseType}<string, ${mapType( prop.additionalProperties, true, schema, level, prefix )}>`;
			} else {
				returnType = `${baseType}<string, mixed>`;
			}
			break;
		default:
			returnType = getPHPType( type );
			break;
	}

	return `${requiredMarker}${returnType}`;
}

/**
 * @param {object} prop
 * @param {object} schema
 * @returns {object}
 */
function resolveRef( prop, schema ) {
	if ( ! prop.$ref ) {
		return prop;
	}

	if ( prop.$ref.startsWith( '#/definitions/' ) ) {
		const definition = prop.$ref.replace( '#/definitions/', '' );
		const refProp = schema.definitions[definition] || prop;
		refProp.phpStanType = refProp.phpStanType || definition;
		return refProp;
	}

	return prop;
}

/**
 * @param {string} type
 * @returns {string}
 */
function getPHPType( type ) {
	switch ( type ) {
		case 'string':
			return 'string';
		case 'null':
			return 'null';
		case 'number':
			return 'float';
		case 'integer':
			return 'int';
		case 'boolean':
			return 'bool';
		case 'array':
		case 'object':
			return 'array';
		default:
			return `'${type}'`;
	}
}
